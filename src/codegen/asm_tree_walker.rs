use crate::{
    asm::{instruction::Instruction, register::Register, register_counter::RegisterCounter},
    ast::{
        array_node::ArrayNode,
        assignment_node::AssignmentNode,
        ast_node::{ASTNodeTrait, SpannedNode},
        binary_op_node::{BinaryOpNode, BinaryOperation},
        call_node::CallNode,
        decl_node::DeclNode,
        expression_node::ExpressionNode,
        float_node::FloatNode,
        function_def_node::FunctionDefNode,
        int_node::IntNode,
        program_node::ProgramNode,
        range_node::RangeNode,
        return_node::ReturnNode,
        string_node::StringNode,
        var_init_node::VarInitNode,
        var_node::VarNode,
    },
    codegen::{tree_walker, tree_walker::ContextHolder},
    context::Context,
    errors::compiler_error::CompilerError,
    interpreter::{constant_pool::ConstantPool, lpc_value::LPCValue, program::Program},
    parser::span::Span,
    semantic::{function_symbol::FunctionSymbol, lpc_type::LPCType, symbol::Symbol},
};
use multimap::MultiMap;
use std::collections::HashMap;
use tree_walker::TreeWalker;

/// Really just a `pc` index in the vm.
type Address = usize;

/// Partition on whether the value is stored in registers or memory, to help select instructions
enum OperationType {
    Register,
    Memory,
}

/// A tree walker that generates assembly language instructions based on an AST.
#[derive(Debug, Default)]
pub struct AsmTreeWalker {
    /// The vector of instructions generated by this walker
    pub instructions: Vec<Instruction>,

    /// Code spans, corresponding to the instructions, for use in runtime error messaging
    pub debug_spans: Vec<Option<Span>>,

    /// The map of labels, to their respective addresses
    pub labels: HashMap<String, Address>,

    /// The map of function Symbols, to their respective addresses
    pub functions: HashMap<FunctionSymbol, Address>,

    /// Track where the result of a child branch is
    current_result: Register,

    /// The internal counter to track which registers are used.
    register_counter: RegisterCounter,

    /// The counter for tracking globals
    global_counter: RegisterCounter,

    /// All constants (really only string literals) in the program
    constants: ConstantPool,

    /// The compilation context
    context: Context,
}

impl AsmTreeWalker {
    /// Create a new `AsmTreeWalker` that consumes the passed scopes
    ///
    /// # Arguments
    /// `context` - A `Context` state.
    pub fn new(context: Context) -> Self {
        Self {
            context,
            ..Default::default()
        }
    }

    /// Get a listing of a translated AST, suitable for printing
    ///
    /// # Examples
    /// ```
    /// use lpc_rs::ast::binary_op_node::{BinaryOpNode, BinaryOperation};
    /// use lpc_rs::ast::int_node::IntNode;
    /// use lpc_rs::ast::expression_node::ExpressionNode;
    /// use lpc_rs::codegen::asm_tree_walker::AsmTreeWalker;
    /// use lpc_rs::codegen::tree_walker::TreeWalker;
    ///
    /// let mut node = BinaryOpNode {
    ///     l: Box::new(ExpressionNode::Int(IntNode::new(123))),
    ///     r: Box::new(ExpressionNode::Int(IntNode::new(456))),
    ///     op: BinaryOperation::Sub,
    ///     span: None
    /// };
    /// let mut walker = AsmTreeWalker::default();
    ///
    /// walker.visit_binary_op(&mut node);
    ///
    /// for instruction in walker.listing() {
    ///     println!("{}", instruction);
    /// }
    /// ```
    pub fn listing(&self) -> Vec<String> {
        let mut v = vec![];

        // invert these maps for by-address lookup
        let functions_by_pc = self
            .functions
            .values()
            .zip(self.functions.keys())
            .collect::<HashMap<_, _>>();

        // use MultiMap as multiple labels can be at the same address
        let labels_by_pc = self
            .labels
            .values()
            .zip(self.labels.keys())
            .collect::<MultiMap<_, _>>();

        for (counter, instruction) in self.instructions.iter().enumerate() {
            if let Some(sym) = functions_by_pc.get(&counter) {
                v.push(format!(
                    "fn {} num_args={} num_locals={}:",
                    sym.name, sym.num_args, sym.num_locals
                ));
            }
            if let Some(vec) = labels_by_pc.get_vec(&counter) {
                for label in vec {
                    v.push(format!("{}:", label));
                }
            }
            v.push(format!("    {}", instruction));
        }

        v
    }

    /// Return a map of function names to their corresponding full symbol
    pub fn function_map(&self) -> HashMap<String, FunctionSymbol> {
        let mut map = HashMap::new();

        for sym in self.functions.keys() {
            map.insert(sym.name.clone(), sym.clone());
        }

        map
    }

    /// Convert this walker's data into a Program
    pub fn to_program(&self, filepath: &str) -> Program {
        // These are expected and assumed to be in 1:1 correspondence at runtime
        assert_eq!(self.instructions.len(), self.debug_spans.len());

        Program {
            instructions: self.instructions.to_vec(),
            debug_spans: self.debug_spans.to_vec(),
            filename: filepath.to_string(),
            labels: self.labels.clone(),
            functions: self.function_map(),
            constants: self.constants.clone(),
            num_globals: self.global_counter.get_count(),
        }
    }

    /// Get a reference to a symbol in the current scope
    fn lookup_symbol(&self, name: &str) -> Option<&Symbol> {
        self.context.scopes.lookup(name)
    }

    /// Get a mutable reference to a symbol in the current scope
    fn lookup_symbol_mut(&mut self, name: &str) -> Option<&mut Symbol> {
        self.context.scopes.lookup_mut(name)
    }

    /// Check for a symbol in the global scope
    fn lookup_global(&self, name: &str) -> Option<&Symbol> {
        self.context.scopes.lookup_global(name)
    }

    /// encapsulate vars that can find themselves if they're global
    fn lookup_var_symbol(&self, node: &VarNode) -> Option<&Symbol> {
        if node.global {
            self.lookup_global(&node.name)
        } else {
            self.lookup_symbol(&node.name)
        }
    }

    /// helper to choose operation instructions
    fn to_operation_type(&self, node: &ExpressionNode) -> OperationType {
        match node {
            ExpressionNode::Int(_) => OperationType::Register,
            ExpressionNode::Float(_) => OperationType::Register,
            ExpressionNode::String(_) => OperationType::Memory,
            ExpressionNode::Array(_) => OperationType::Memory,
            ExpressionNode::Assignment(node) => self.to_operation_type(&node.lhs),
            ExpressionNode::BinaryOp(node) => {
                let left_type = self.to_operation_type(&node.l);
                let right_type = self.to_operation_type(&node.r);
                match (left_type, right_type) {
                    (OperationType::Register, OperationType::Register) => OperationType::Register,
                    _ => OperationType::Memory,
                }
            }
            // TODO: Calls can be optimized if we can get the return types available here
            ExpressionNode::Call(_) => OperationType::Memory,
            ExpressionNode::CommaExpression(_) => OperationType::Memory,
            ExpressionNode::Range(_) => OperationType::Memory,
            ExpressionNode::Var(v) => {
                let ty = self.lookup_var_symbol(&v).unwrap().type_;

                match ty {
                    LPCType::Int(false) => OperationType::Register,
                    LPCType::Float(false) => OperationType::Register,
                    _ => OperationType::Memory,
                }
            }
        }
    }

    /// The main switch to determine which instruction we select for a binary operation
    fn choose_op_instruction(
        &self,
        node: &BinaryOpNode,
        reg_left: Register,
        reg_right: Register,
        reg_result: Option<Register>,
    ) -> Instruction {
        match node.op {
            BinaryOperation::Add => {
                self.choose_add_instruction(&node, reg_left, reg_right, reg_result)
            }
            BinaryOperation::Sub => Instruction::ISub(reg_left, reg_right, reg_result.unwrap()),
            BinaryOperation::Mul => {
                self.choose_mul_instruction(&node, reg_left, reg_right, reg_result)
            }
            BinaryOperation::Div => Instruction::IDiv(reg_left, reg_right, reg_result.unwrap()),
            BinaryOperation::Index => Instruction::ALoad(reg_left, reg_right, reg_result.unwrap()),
        }
    }

    /// Allows for recursive determination of typed add instructions
    fn choose_add_instruction(
        &self,
        node: &BinaryOpNode,
        reg_left: Register,
        reg_right: Register,
        reg_result: Option<Register>,
    ) -> Instruction {
        let left_type = self.to_operation_type(&node.l);
        let right_type = self.to_operation_type(&node.r);

        match (left_type, right_type) {
            (OperationType::Register, OperationType::Register) => {
                Instruction::IAdd(reg_left, reg_right, reg_result.unwrap())
            }
            _ => Instruction::MAdd(reg_left, reg_right, reg_result.unwrap()),
        }
    }

    /// Allows for recursive determination of typed mul instructions
    fn choose_mul_instruction(
        &self,
        node: &BinaryOpNode,
        reg_left: Register,
        reg_right: Register,
        reg_result: Option<Register>,
    ) -> Instruction {
        let left_type = self.to_operation_type(&node.l);
        let right_type = self.to_operation_type(&node.r);

        match (left_type, right_type) {
            (OperationType::Register, OperationType::Register) => {
                Instruction::IMul(reg_left, reg_right, reg_result.unwrap())
            }
            _ => Instruction::MMul(reg_left, reg_right, reg_result.unwrap()),
        }
    }

    /// A special case for function def parameters, where we don't want to generate code
    /// for default arguments - we just want to have it on hand to refer to
    /// when we generate code for calls.
    fn visit_parameter(&mut self, node: &VarInitNode) {
        let current_register;

        current_register = self.register_counter.next().unwrap();

        let symbol = self.lookup_symbol_mut(&node.name);
        if let Some(sym) = symbol {
            sym.location = Some(current_register);
        }
    }

    /// Emit the instruction(s) to take the range of an array
    /// # Arguments
    /// `array` - The register holding the reference to the array we're taking a slice from.
    /// `node` - A reference to the `RangeNode` that holds the range of the slice we're taking.
    fn emit_range(&mut self, array: Register, node: &mut RangeNode) {
        println!("node? {:?}", node);
        let first_index = if let Some(expr) = &mut *node.l {
            let _ = expr.visit(self);
            self.current_result
        } else {
            // Default to 0. No instruction needed as the value in registers defaults to int 0.
            self.register_counter.next().unwrap()
        };

        let second_index = if let Some(expr) = &mut *node.r {
            let _ = expr.visit(self);
            self.current_result
        } else {
            // A missing range end means just go to the end of the array.
            let register = self.register_counter.next().unwrap();
            let instruction = Instruction::IConst(register, -1);
            self.instructions.push(instruction);
            self.debug_spans.push(node.span);
            register
        };

        let result = self.register_counter.next().unwrap();
        self.current_result = result;
        self.instructions.push(Instruction::ARange(
            array,
            first_index,
            second_index,
            result,
        ));
        self.debug_spans.push(node.span);
    }
}

impl ContextHolder for AsmTreeWalker {
    fn into_context(self) -> Context {
        self.context
    }
}

impl TreeWalker for AsmTreeWalker {
    fn visit_program(&mut self, program: &mut ProgramNode) -> Result<(), CompilerError> {
        self.context.scopes.goto_root();
        for expr in &mut program.body {
            let _ = expr.visit(self);
        }
        self.context.scopes.pop();

        Ok(())
    }

    fn visit_call(&mut self, node: &mut CallNode) -> Result<(), CompilerError> {
        let mut arg_results = vec![];

        let params = self.context.function_params.get(&node.name);

        if let Some(function_args) = params {
            let mut function_args = function_args.to_vec();

            for (idx, function_arg) in function_args.iter_mut().enumerate() {
                // use passed parameters, or default parameters if applicable.
                if let Some(arg) = node.arguments.get_mut(idx) {
                    arg.visit(self)?;
                    arg_results.push(self.current_result);
                } else if let Some(arg) = function_arg {
                    arg.visit(self)?;
                    arg_results.push(self.current_result);
                }
            }
        } else {
            // TODO: This is where efuns are handled
            for argument in &mut node.arguments {
                argument.visit(self)?;
                arg_results.push(self.current_result);
            }
        }

        let start_register = self.register_counter.next();
        let mut register = start_register;

        // copy each result to the start of the arg register
        for result in &arg_results {
            self.instructions
                .push(Instruction::RegCopy(*result, register.unwrap()));
            self.debug_spans.push(node.span);
            register = self.register_counter.next();
        }

        // Undo the final call to .next() to avoid skipping a register
        self.register_counter.go_back();

        let instruction = Instruction::Call {
            name: node.name.clone(),
            num_args: arg_results.len(),
            initial_arg: start_register.unwrap(),
        };

        self.instructions.push(instruction);
        self.debug_spans.push(node.span);
        self.current_result = Register(0); // returned results are in r0

        Ok(())
    }

    fn visit_int(&mut self, node: &mut IntNode) -> Result<(), CompilerError> {
        let register = self.register_counter.next();
        self.current_result = register.unwrap();
        let instruction = match node.value {
            0 => Instruction::IConst0(register.unwrap()),
            1 => Instruction::IConst1(register.unwrap()),
            v => Instruction::IConst(register.unwrap(), v),
        };
        self.instructions.push(instruction);
        self.debug_spans.push(node.span);

        Ok(())
    }

    fn visit_float(&mut self, node: &mut FloatNode) -> Result<(), CompilerError> {
        let register = self.register_counter.next();
        self.current_result = register.unwrap();
        let instruction = Instruction::FConst(self.current_result, node.value);
        self.instructions.push(instruction);
        self.debug_spans.push(node.span);

        Ok(())
    }

    fn visit_string(&mut self, node: &mut StringNode) -> Result<(), CompilerError> {
        let register = self.register_counter.next().unwrap();
        self.current_result = register;

        let index = self.constants.insert(LPCValue::from(&node.value));

        self.instructions.push(Instruction::SConst(register, index));
        self.debug_spans.push(node.span);

        Ok(())
    }

    fn visit_binary_op(&mut self, node: &mut BinaryOpNode) -> Result<(), CompilerError> {
        node.l.visit(self)?;
        let reg_left = self.current_result;

        // Ranges need special handling that complicates this function otherwise, due to
        // the visit to node.r needing to handle multiple results.
        if node.op == BinaryOperation::Index {
            if let ExpressionNode::Range(range_node) = &mut *node.r {
                self.emit_range(reg_left, range_node);
                return Ok(());
            }
        }

        node.r.visit(self)?;
        let reg_right = self.current_result;

        let reg_result = self.register_counter.next();
        self.current_result = reg_result.unwrap();

        let instruction = self.choose_op_instruction(node, reg_left, reg_right, reg_result);
        self.instructions.push(instruction);
        self.debug_spans.push(node.span);

        Ok(())
    }

    fn visit_function_def(&mut self, node: &mut FunctionDefNode) -> Result<(), CompilerError> {
        let return_address = self.instructions.len();

        let len = self.instructions.len();
        self.context.scopes.goto_function(&node.name);
        self.register_counter.reset();

        for parameter in &node.parameters {
            self.visit_parameter(parameter);
        }

        for expression in &mut node.body {
            expression.visit(self)?;
        }

        // force a final return if one isn't already there.
        if self.instructions.len() == len || *self.instructions.last().unwrap() != Instruction::Ret
        {
            // TODO: This should emit a warning unless the return type is void
            self.instructions.push(Instruction::Ret);
            self.debug_spans.push(node.span);
        }

        self.context.scopes.pop();

        let num_args = node.parameters.len();
        self.functions.insert(
            FunctionSymbol {
                name: node.name.clone(),
                num_args,
                num_locals: self.register_counter.get_count() - num_args,
                address: return_address,
            },
            return_address,
        );

        Ok(())
    }

    fn visit_return(&mut self, node: &mut ReturnNode) -> Result<(), CompilerError> {
        if let Some(expression) = &mut node.value {
            expression.visit(self)?;
            let copy = Instruction::RegCopy(self.current_result, Register(0));
            self.instructions.push(copy);
            self.debug_spans.push(expression.span());
        }

        self.instructions.push(Instruction::Ret);
        self.debug_spans.push(node.span);

        Ok(())
    }

    fn visit_decl(&mut self, node: &mut DeclNode) -> Result<(), CompilerError> {
        for init in &mut node.initializations {
            let _ = self.visit_var_init(init);
        }

        Ok(())
    }

    fn visit_var_init(&mut self, node: &mut VarInitNode) -> Result<(), CompilerError> {
        let current_register;
        let symbol = self.lookup_symbol(&node.name);

        let sym = symbol.unwrap_or_else(|| {
            panic!(
                "Missing symbol, that passed semantic checks: {}",
                &node.name
            )
        });

        let global = sym.is_global();

        if let Some(expression) = &mut node.value {
            expression.visit(self)?;

            current_register = self.register_counter.current();
        } else {
            // Default value to 0 when uninitialized.
            current_register = self.register_counter.next().unwrap();
        }

        if global {
            // Store the reference in the globals register.
            // Using next() "wastes" global r0, but makes it possible for us to skip a
            // bunch of conditionals.
            let dest_register = self.global_counter.next().unwrap();
            let instruction = Instruction::GStore(current_register, dest_register);

            self.instructions.push(instruction);
            self.debug_spans.push(node.span);
        }

        let current_global_register = self.global_counter.current();
        let symbol = self.lookup_symbol_mut(&node.name);

        if let Some(sym) = symbol {
            if global {
                sym.location = Some(current_global_register);
                self.global_counter.next();
            } else {
                sym.location = Some(current_register);
            }
        }

        Ok(())
    }

    fn visit_var(&mut self, node: &mut VarNode) -> Result<(), CompilerError> {
        let sym = self.lookup_var_symbol(node).unwrap();

        let sym_loc = sym.location.unwrap();

        if sym.is_global() {
            let result_register = self.register_counter.next().unwrap();
            let instruction = Instruction::GLoad(sym_loc, result_register);
            self.instructions.push(instruction);
            self.debug_spans.push(node.span);

            self.current_result = result_register;
        } else {
            self.current_result = sym_loc;
        }

        Ok(())
    }

    fn visit_assignment(&mut self, node: &mut AssignmentNode) -> Result<(), CompilerError> {
        node.rhs.visit(self)?;
        let rhs_result = self.current_result;
        let lhs = &mut *node.lhs;

        match lhs.clone() {
            ExpressionNode::Var(VarNode { name, global, .. }) => {
                node.lhs.visit(self)?;
                let lhs_result = self.current_result;

                let assign = Instruction::RegCopy(rhs_result, lhs_result);

                self.instructions.push(assign);
                self.debug_spans.push(node.span);

                // Copy over globals if necessary
                if global {
                    if let Some(Symbol {
                        scope_id: 0,
                        location: Some(register),
                        ..
                    }) = self.lookup_global(&name)
                    {
                        let store = Instruction::GStore(lhs_result, *register);
                        self.instructions.push(store);
                        self.debug_spans.push(node.span);
                    }
                }

                self.current_result = lhs_result;
            }
            ExpressionNode::BinaryOp(BinaryOpNode {
                op: BinaryOperation::Index,
                ref mut l,
                ref mut r,
                ..
            }) => {
                let _ = l.visit(self);
                let var_result = self.current_result;
                let _ = r.visit(self);
                let index_result = self.current_result;

                let assign = Instruction::AStore(rhs_result, var_result, index_result);

                self.instructions.push(assign);
                self.debug_spans.push(node.span);

                self.current_result = rhs_result;
            }
            _x => {
                panic!("trying to assign to an invalid lvalue")
            }
        }

        Ok(())
    }

    fn visit_array(&mut self, node: &mut ArrayNode) -> Result<(), CompilerError> {
        let mut items = Vec::with_capacity(node.value.len());
        for member in &mut node.value {
            let _ = member.visit(self);
            items.push(self.current_result);
        }

        let register = self.register_counter.next().unwrap();
        self.current_result = register;
        self.instructions.push(Instruction::AConst(register, items));
        self.debug_spans.push(node.span);

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        asm::instruction::Instruction::{
            AConst, AStore, Call, GLoad, GStore, IAdd, IConst, IConst0, IConst1, RegCopy, Ret,
            SConst,
        },
        ast::{
            assignment_node::AssignmentOperation, ast_node::ASTNode,
            comma_expression_node::CommaExpressionNode, expression_node::ExpressionNode,
        },
        codegen::scope_walker::ScopeWalker,
        lpc_parser,
        parser::{lexer::LexWrapper, span::Span},
        semantic::lpc_type::LPCType,
    };
    use crate::compiler::preprocess_string;
    use crate::parser::lexer::TokenVecWrapper;

    #[test]
    fn test_walk_tree_populates_the_instructions() {
        let mut scope_walker = ScopeWalker::default();
        let program = "
            int main() {
                1 + 3 - 5;
                print(4 + 5);
            }
        ";

        let (code, _) = preprocess_string("foo.c", program).unwrap();

        let mut tree = lpc_parser::ProgramParser::new()
            .parse(TokenVecWrapper::new(code))
            .unwrap();

        let _ = scope_walker.visit_program(&mut tree);
        let context = scope_walker.into_context();

        let mut walker = AsmTreeWalker::new(context);
        let _ = tree.visit(&mut walker);

        let expected = vec![
            IConst(Register(1), -1),
            IConst(Register(2), 9),
            RegCopy(Register(2), Register(3)),
            Call {
                name: String::from("print"),
                num_args: 1,
                initial_arg: Register(3),
            },
            Ret, // Automatically added
        ];

        assert_eq!(walker.instructions, expected);
    }

    mod test_visit_call {
        use super::*;
        use crate::asm::instruction::Instruction::Call;

        #[test]
        fn test_visit_call_populates_the_instructions() {
            let mut walker = AsmTreeWalker::default();
            let call = "print(4 - 5)";
            let mut tree = lpc_parser::CallParser::new()
                .parse(LexWrapper::new(call))
                .unwrap();

            let _ = walker.visit_call(&mut tree);

            let expected = vec![
                IConst(Register(1), -1),
                RegCopy(Register(1), Register(2)),
                Call {
                    name: String::from("print"),
                    num_args: 1,
                    initial_arg: Register(2),
                },
            ];

            assert_eq!(walker.instructions, expected);
        }

        #[test]
        fn test_visit_call_populates_the_instructions_with_defaults() {
            let mut function_params = HashMap::new();

            function_params.insert(
                String::from("foo"),
                vec![None, Some(ExpressionNode::from("muffuns"))],
            );

            let context = Context {
                function_params,
                ..Context::default()
            };

            let mut walker = AsmTreeWalker::new(context);
            let call = "foo(666)";
            let mut tree = lpc_parser::CallParser::new()
                .parse(LexWrapper::new(call))
                .unwrap();

            let _ = walker.visit_call(&mut tree);

            let expected = vec![
                IConst(Register(1), 666),
                SConst(Register(2), 0),
                RegCopy(Register(1), Register(3)),
                RegCopy(Register(2), Register(4)),
                Call {
                    name: "foo".to_string(),
                    num_args: 2,
                    initial_arg: Register(3),
                },
            ];

            assert_eq!(walker.instructions, expected);
        }
    }

    #[test]
    fn test_visit_int_populates_the_instructions() {
        let mut walker = AsmTreeWalker::default();

        let mut tree = IntNode::new(666);
        let mut tree0 = IntNode::new(0);
        let mut tree1 = IntNode::new(1);

        let _ = walker.visit_int(&mut tree);
        let _ = walker.visit_int(&mut tree0);
        let _ = walker.visit_int(&mut tree1);

        let expected = vec![
            IConst(Register(1), 666),
            IConst0(Register(2)),
            IConst1(Register(3)),
        ];

        assert_eq!(walker.instructions, expected);
    }

    mod test_binary_op {
        use super::*;
        use crate::asm::instruction::Instruction::{ALoad, ARange, FConst, IConst0, IMul, MAdd};

        #[test]
        fn test_visit_binary_op_populates_the_instructions_for_ints() {
            let mut walker = AsmTreeWalker::default();

            let mut node = BinaryOpNode {
                l: Box::new(ExpressionNode::Int(IntNode::new(666))),
                r: Box::new(ExpressionNode::BinaryOp(BinaryOpNode {
                    l: Box::new(ExpressionNode::Int(IntNode::new(123))),
                    r: Box::new(ExpressionNode::Int(IntNode::new(456))),
                    op: BinaryOperation::Add,
                    span: None,
                })),
                op: BinaryOperation::Mul,
                span: None,
            };

            let _ = walker.visit_binary_op(&mut node);

            let expected = vec![
                IConst(Register(1), 666),
                IConst(Register(2), 123),
                IConst(Register(3), 456),
                IAdd(Register(2), Register(3), Register(4)),
                IMul(Register(1), Register(4), Register(5)),
            ];

            assert_eq!(walker.instructions, expected);
        }

        #[test]
        fn test_visit_binary_op_populates_the_instructions_for_floats() {
            let mut context = Context::default();
            context.scopes.push_new();
            let mut sym = Symbol::new("foo", LPCType::Float(false));
            sym.location = Some(Register(1));
            context.scopes.get_current_mut().unwrap().insert(sym);

            let mut walker = AsmTreeWalker::new(context);

            let mut node = BinaryOpNode {
                l: Box::new(ExpressionNode::Float(FloatNode::new(123.45))),
                r: Box::new(ExpressionNode::BinaryOp(BinaryOpNode {
                    l: Box::new(ExpressionNode::Var(VarNode {
                        name: "foo".to_string(),
                        span: None,
                        global: false,
                    })),
                    r: Box::new(ExpressionNode::Int(IntNode::new(456))),
                    op: BinaryOperation::Mul,
                    span: None,
                })),
                op: BinaryOperation::Add,
                span: None,
            };

            let _ = walker.visit_binary_op(&mut node);

            let expected = vec![
                FConst(Register(1), 123.45),
                GLoad(Register(1), Register(2)),
                IConst(Register(3), 456),
                IMul(Register(2), Register(3), Register(4)),
                IAdd(Register(1), Register(4), Register(5)),
            ];

            assert_eq!(walker.instructions, expected);
        }

        #[test]
        fn test_visit_binary_op_populates_the_instructions_for_strings() {
            let mut walker = AsmTreeWalker::default();

            let mut node = BinaryOpNode {
                l: Box::new(ExpressionNode::String(StringNode::new("foo"))),
                r: Box::new(ExpressionNode::BinaryOp(BinaryOpNode {
                    l: Box::new(ExpressionNode::String(StringNode::new("bar"))),
                    r: Box::new(ExpressionNode::String(StringNode::new("baz"))),
                    op: BinaryOperation::Add,
                    span: None,
                })),
                op: BinaryOperation::Add,
                span: None,
            };

            let _ = walker.visit_binary_op(&mut node);

            let expected = vec![
                SConst(Register(1), 0),
                SConst(Register(2), 1),
                SConst(Register(3), 2),
                MAdd(Register(2), Register(3), Register(4)),
                MAdd(Register(1), Register(4), Register(5)),
            ];

            assert_eq!(walker.instructions, expected);
        }

        #[test]
        fn test_visit_binary_op_populates_the_instructions_for_arrays() {
            let mut walker = AsmTreeWalker::default();

            let mut node = BinaryOpNode {
                l: Box::new(ExpressionNode::from(vec![ExpressionNode::from(123)])),
                r: Box::new(ExpressionNode::from(vec![ExpressionNode::from(456)])),
                op: BinaryOperation::Add,
                span: None,
            };

            let _ = walker.visit_binary_op(&mut node);

            let expected = vec![
                IConst(Register(1), 123),
                AConst(Register(2), vec![Register(1)]),
                IConst(Register(3), 456),
                AConst(Register(4), vec![Register(3)]),
                MAdd(Register(2), Register(4), Register(5)),
            ];

            assert_eq!(walker.instructions, expected);
        }

        #[test]
        fn test_visit_binary_op_populates_the_instructions_for_indexes() {
            let context = Context::default();
            let mut walker = AsmTreeWalker::new(context);

            let mut node = BinaryOpNode {
                l: Box::new(ExpressionNode::from(vec![ExpressionNode::from(123)])),
                r: Box::new(ExpressionNode::from(0)),
                op: BinaryOperation::Index,
                span: None,
            };

            let _ = walker.visit_binary_op(&mut node);

            let expected = vec![
                IConst(Register(1), 123),
                AConst(Register(2), vec![Register(1)]),
                IConst0(Register(3)),
                ALoad(Register(2), Register(3), Register(4)),
            ];

            assert_eq!(walker.instructions, expected);
        }

        #[test]
        fn test_visit_binary_op_populates_the_instructions_for_slices() {
            let mut walker = AsmTreeWalker::default();

            let mut node = BinaryOpNode {
                l: Box::new(ExpressionNode::from(vec![ExpressionNode::from(123)])),
                r: Box::new(ExpressionNode::Range(RangeNode {
                    l: Box::new(Some(ExpressionNode::from(1))),
                    r: Box::new(None),
                    span: None,
                })),
                op: BinaryOperation::Index,
                span: None,
            };

            let _ = walker.visit_binary_op(&mut node);

            println!("isa' {:?}", walker.instructions);

            let expected = vec![
                IConst(Register(1), 123),
                AConst(Register(2), vec![Register(1)]),
                IConst1(Register(3)),
                IConst(Register(4), -1),
                ARange(Register(2), Register(3), Register(4), Register(5)),
            ];

            assert_eq!(walker.instructions, expected);
        }
    }

    #[test]
    fn test_visit_string_populates_the_instructions() {
        let mut walker = AsmTreeWalker::default();
        let mut node = StringNode::new("marf");
        let mut node2 = StringNode::new("tacos");
        let mut node3 = StringNode::new("marf");

        let _ = walker.visit_string(&mut node);
        let _ = walker.visit_string(&mut node2);
        let _ = walker.visit_string(&mut node3);

        let expected = vec![
            SConst(Register(1), 0),
            SConst(Register(2), 1),
            SConst(Register(3), 0), // reuses constant
        ];

        assert_eq!(walker.instructions, expected);
    }

    #[test]
    fn test_visit_function_def_populates_the_data() {
        let mut scope_walker = ScopeWalker::default();
        let _walker = AsmTreeWalker::default();
        let call = "int main(int i) { return i + 4; }";
        let tree = lpc_parser::DefParser::new()
            .parse(LexWrapper::new(call))
            .unwrap();

        let mut node = if let ASTNode::FunctionDef(node) = tree {
            node
        } else {
            panic!("Didn't receive a function def?");
        };

        let _ = scope_walker.visit_function_def(&mut node);

        let mut context = scope_walker.into_context();
        context.scopes.goto_root();

        let mut walker = AsmTreeWalker::new(context);
        let _ = walker.visit_function_def(&mut node);

        let expected = vec![
            IConst(Register(2), 4),
            IAdd(Register(1), Register(2), Register(3)),
            RegCopy(Register(3), Register(0)),
            Ret,
        ];

        assert_eq!(walker.instructions, expected);

        let address: Address = 0;

        let sym = FunctionSymbol {
            name: "main".to_string(),
            num_args: 1,
            num_locals: 2,
            address,
        };

        assert_eq!(walker.functions.get(&sym).unwrap(), &address);
    }

    #[test]
    fn visit_return_populates_the_instructions() {
        let mut walker = AsmTreeWalker::default();

        let mut node = ReturnNode::new(Some(ExpressionNode::from(IntNode::new(666))));
        let _ = walker.visit_return(&mut node);

        let expected = vec![
            IConst(Register(1), 666),
            RegCopy(Register(1), Register(0)),
            Ret,
        ];

        assert_eq!(walker.instructions, expected);

        /* === */

        let mut walker = AsmTreeWalker::default();
        let mut node = ReturnNode::new(None);
        let _ = walker.visit_return(&mut node);

        let expected = vec![Ret];

        assert_eq!(walker.instructions, expected);
    }

    #[test]
    fn test_decl_sets_scope_and_instructions() {
        let call = "int foo = 1, *bar = ({ 56 })";
        let mut tree = lpc_parser::DeclParser::new()
            .parse(LexWrapper::new(call))
            .unwrap();

        let mut scope_walker = ScopeWalker::default();
        let _ = scope_walker.visit_decl(&mut tree);

        let context = scope_walker.into_context();
        let mut walker = AsmTreeWalker::new(context);
        let _ = walker.visit_decl(&mut tree);

        let expected = vec![
            IConst1(Register(1)),
            GStore(Register(1), Register(1)),
            IConst(Register(2), 56),
            AConst(Register(3), vec![Register(2)]),
            GStore(Register(3), Register(3)),
        ];

        assert_eq!(walker.instructions, expected);

        let scope = walker.context.scopes.get_current().unwrap();
        assert_eq!(
            scope.lookup("foo").unwrap(),
            Symbol {
                name: String::from("foo"),
                type_: LPCType::Int(false),
                static_: false,
                location: Some(Register(1)),
                scope_id: 0,
                span: Some(Span {
                    file_id: 0,
                    l: 4,
                    r: 11
                })
            }
        );
        assert_eq!(
            scope.lookup("bar").unwrap(),
            Symbol {
                name: String::from("bar"),
                type_: LPCType::Int(true),
                static_: false,
                location: Some(Register(3)),
                scope_id: 0,
                span: Some(Span {
                    file_id: 0,
                    l: 13,
                    r: 25
                })
            }
        );
    }

    #[test]
    fn test_visit_var_loads_the_var_and_sets_the_result_for_globals() {
        let mut context = Context::default();
        context.scopes.push_new();

        let mut walker = AsmTreeWalker::new(context);

        insert_symbol(
            &mut walker,
            Symbol {
                name: "marf".to_string(),
                type_: LPCType::Int(false),
                static_: false,
                location: Some(Register(666)),
                scope_id: 0,
                span: None,
            },
        );
        // push a local scope with a matching variable in a different location
        walker.context.scopes.push_new();
        insert_symbol(
            &mut walker,
            Symbol {
                name: "marf".to_string(),
                type_: LPCType::Int(false),
                static_: false,
                location: Some(Register(222)),
                scope_id: 1,
                span: None,
            },
        );

        let mut node = VarNode {
            name: "marf".to_string(),
            span: None,
            global: true,
        };

        let _ = walker.visit_var(&mut node);
        assert_eq!(walker.current_result, Register(1)); // global loaded into r1

        let expected = vec![GLoad(Register(666), Register(1))];
        assert_eq!(walker.instructions, expected);
    }

    #[test]
    fn test_visit_var_sets_the_result_for_locals() {
        let mut context = Context::default();
        context.scopes.push_new();
        let mut walker = AsmTreeWalker::new(context);

        insert_symbol(
            &mut walker,
            // push a global marf to ensure we don't find it.
            Symbol {
                name: "marf".to_string(),
                type_: LPCType::Int(false),
                static_: false,
                location: Some(Register(444)),
                scope_id: 0,
                span: None,
            },
        );
        walker.context.scopes.push_new(); // push a local scope
        insert_symbol(
            &mut walker,
            Symbol {
                name: "marf".to_string(),
                type_: LPCType::Int(false),
                static_: false,
                location: Some(Register(666)),
                scope_id: 1,
                span: None,
            },
        );

        let mut node = VarNode::new("marf");

        let _ = walker.visit_var(&mut node);
        assert_eq!(walker.current_result, Register(666));

        let expected = vec![];
        assert_eq!(walker.instructions, expected);
    }

    #[test]
    fn test_visit_assignment_populates_the_instructions_for_globals() {
        let mut context = Context::default();
        context.scopes.push_new();
        let mut walker = AsmTreeWalker::new(context);

        let sym = Symbol {
            name: "marf".to_string(),
            type_: LPCType::Int(false),
            static_: false,
            location: Some(Register(666)),
            scope_id: 0,
            span: None,
        };
        insert_symbol(&mut walker, sym);

        // push a different, local `marf`, to ensure that we don't find it for this assignment.
        walker.context.scopes.push_new();
        let sym = Symbol {
            name: "marf".to_string(),
            type_: LPCType::Int(false),
            static_: false,
            location: Some(Register(123)),
            scope_id: 1,
            span: None,
        };
        insert_symbol(&mut walker, sym);

        let mut node = AssignmentNode {
            lhs: Box::new(ExpressionNode::Var(VarNode {
                name: "marf".to_string(),
                span: None,
                global: true,
            })),
            rhs: Box::new(ExpressionNode::Int(IntNode::new(-12))),
            op: AssignmentOperation::Simple,
            span: None,
        };

        let _ = walker.visit_assignment(&mut node);
        assert_eq!(
            walker.instructions,
            [
                IConst(Register(1), -12),
                GLoad(Register(666), Register(2)),
                RegCopy(Register(1), Register(2)),
                GStore(Register(2), Register(666))
            ]
        );
    }

    #[test]
    fn test_visit_assignment_populates_the_instructions_for_locals() {
        let mut context = Context::default();
        context.scopes.push_new();
        context.scopes.push_new();
        let mut walker = AsmTreeWalker::new(context);

        let sym = Symbol {
            name: "marf".to_string(),
            type_: LPCType::Int(false),
            static_: false,
            location: Some(Register(666)),
            scope_id: 1,
            span: None,
        };

        insert_symbol(&mut walker, sym);

        let mut node = AssignmentNode {
            lhs: Box::new(ExpressionNode::Var(VarNode::new("marf"))),
            rhs: Box::new(ExpressionNode::Int(IntNode::new(-12))),
            op: AssignmentOperation::Simple,
            span: None,
        };

        let _ = walker.visit_assignment(&mut node);
        assert_eq!(
            walker.instructions,
            [
                IConst(Register(1), -12),
                RegCopy(Register(1), Register(666))
            ]
        );
    }

    #[test]
    fn test_visit_assignment_populates_the_instructions_for_array_items() {
        let mut context = Context::default();
        context.scopes.push_new();
        context.scopes.push_new();
        let mut walker = AsmTreeWalker::new(context);

        let sym = Symbol {
            name: "marf".to_string(),
            type_: LPCType::Int(true),
            static_: false,
            location: Some(Register(666)),
            scope_id: 1,
            span: None,
        };

        insert_symbol(&mut walker, sym);

        let mut node = AssignmentNode {
            lhs: Box::new(ExpressionNode::BinaryOp(BinaryOpNode {
                l: Box::new(ExpressionNode::from(VarNode::new("marf"))),
                r: Box::new(ExpressionNode::from(1)),
                op: BinaryOperation::Index,
                span: None,
            })),
            rhs: Box::new(ExpressionNode::from(-12)),
            op: AssignmentOperation::Simple,
            span: None,
        };

        let _ = walker.visit_assignment(&mut node);
        assert_eq!(
            walker.instructions,
            [
                IConst(Register(1), -12),
                IConst1(Register(2)),
                AStore(Register(1), Register(666), Register(2))
            ]
        );
    }

    #[test]
    fn test_visit_array_populates_the_instructions() {
        let mut walker = AsmTreeWalker::default();

        let mut arr = ArrayNode::new(vec![
            ExpressionNode::from(123),
            ExpressionNode::from("foo"),
            ExpressionNode::from(vec![ExpressionNode::from(666)]),
        ]);

        let _ = walker.visit_array(&mut arr);

        let expected = vec![
            IConst(Register(1), 123),
            SConst(Register(2), 0),
            IConst(Register(3), 666),
            AConst(Register(4), vec![Register(3)]),
            AConst(Register(5), vec![Register(1), Register(2), Register(4)]),
        ];

        assert_eq!(walker.instructions, expected);
    }

    #[test]
    fn test_visit_comma_expression_populates_the_instructions() {
        let mut walker = AsmTreeWalker::default();

        let mut expr = CommaExpressionNode::new(vec![
            ExpressionNode::from(123),
            ExpressionNode::from("foo"),
            ExpressionNode::from(vec![ExpressionNode::from(666)]),
        ]);

        let _ = walker.visit_comma_expression(&mut expr);

        let expected = vec![
            IConst(Register(1), 123),
            SConst(Register(2), 0),
            IConst(Register(3), 666),
            AConst(Register(4), vec![Register(3)]),
        ];

        assert_eq!(walker.instructions, expected);
        assert_eq!(walker.current_result, Register(4));
    }

    fn insert_symbol(walker: &mut AsmTreeWalker, symbol: Symbol) {
        if let Some(node_id) = walker.context.scopes.current_id {
            walker
                .context
                .scopes
                .get_mut(node_id)
                .unwrap()
                .insert(symbol)
        }
    }
}
