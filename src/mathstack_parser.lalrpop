use std::str::FromStr;

use crate::ast::program_node::ProgramNode;
use crate::ast::binary_op_node::{BinaryOperation, BinaryOpNode};
use crate::ast::expression_node::ExpressionNode;
use crate::ast::function_def_node::FunctionDefNode;
use crate::ast::int_node::IntNode;
use crate::ast::call_node::CallNode;
use crate::ast::return_node::ReturnNode;
use crate::semantic::lpc_type::LPCReturnType;
use crate::ast::ast_node::ASTNode;

grammar;

match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*([^*]*\*+[^*/])*([^*]*\*+|[^*])*\*/" => { },  // Skip `/* comments */`
    _ // let everything else through
}

SemiSeq<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Program: ProgramNode = <functions:FunctionDef*> => ProgramNode {
    functions
};

pub FunctionDef: FunctionDefNode = {
    <r_type:ReturnType?> <star:"*"?> <name:ID> "(" ")" "{" <body:SemiSeq<Statement>> "}" => {
        let star = if let Some(_) = star { true } else { false };

        let return_type = if let Some(this_type) = r_type {
            match this_type.as_str() {
                "int" => LPCReturnType::Int(star),
                _ => unimplemented!()
            }
        } else {
            LPCReturnType::Int(star)
        };

        FunctionDefNode {
            name,
            body,
            return_type
        }
    }
};

ReturnType: String = "int" => String::from(<>);

pub Statement: ASTNode = {
    <Expression> => ASTNode::from(<>),
    <Return> => ASTNode::from(<>)
};

pub Expression: ExpressionNode = {
    Call => ExpressionNode::Call(<>),
    <AdditiveBinaryExpression>,
    <Factor>
};

pub Return: ReturnNode = {
    "return" => ReturnNode::new(None),
    "return" <Expression> => ReturnNode::new(Some(<>))
}

pub Factor: ExpressionNode = {
    <MultiplicitiveBinaryExpression>,
    <Term>
};

pub AdditiveBinaryExpression: ExpressionNode = {
    <l:Expression> <op:AdditiveBinaryOp> <r:Factor> => {
        ExpressionNode::BinaryOp(BinaryOpNode { l: Box::new(l), r: Box::new(r), op })
    }
};

pub MultiplicitiveBinaryExpression: ExpressionNode = {
    <l:Factor> <op:MultiplicitiveBinaryOp> <r:Term> => {
        ExpressionNode::BinaryOp(BinaryOpNode { l: Box::new(l), r: Box::new(r), op })
    },
};

pub Call: CallNode = {
    <id:ID> "(" <e:Expression> ")" => CallNode {
        arguments: vec![e],
        id
    }
};

AdditiveBinaryOp: BinaryOperation = {
    "+" => BinaryOperation::Add,
    "-" => BinaryOperation::Sub
};

MultiplicitiveBinaryOp: BinaryOperation = {
    "*" => BinaryOperation::Mul,
    "/" => BinaryOperation::Div
};

Term: ExpressionNode = {
    <Int>,
    "(" <Expression> ")",
};

Int: ExpressionNode = <s:r"-?[0-9]+"> => ExpressionNode::Int(
    IntNode {
        value: i64::from_str(s).unwrap()
    }
);

ID: String = r"[\p{Alphabetic}_]\w+" => String::from(<>);