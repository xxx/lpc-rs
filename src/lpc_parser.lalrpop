use itertools::Itertools;
use std::ops::Range;
use std::convert::TryFrom;
use lalrpop_util::ParseError;
use crate::ast::ast_node::{AstNode, SpannedNode};
use crate::ast::assignment_node::{AssignmentOperation, AssignmentNode};
use crate::ast::array_node::ArrayNode;
use crate::ast::binary_op_node::{BinaryOpNode, BinaryOperation};
use crate::ast::block_node::BlockNode;
use crate::ast::break_node::BreakNode;
use crate::ast::call_node::CallNode;
use crate::ast::comma_expression_node::CommaExpressionNode;
use crate::ast::continue_node::ContinueNode;
use crate::ast::decl_node::DeclNode;
use crate::ast::do_while_node::DoWhileNode;
use crate::ast::expression_node::{ExpressionNode, first_span};
use crate::ast::float_node::FloatNode;
use crate::ast::for_node::ForNode;
use crate::ast::for_each_node::{ForEachInit, ForEachNode};
use crate::ast::function_ptr_node::{FunctionPtrNode, FunctionPtrReceiver};
use crate::ast::function_def_node::FunctionDefNode;
use crate::ast::if_node::IfNode;
use crate::ast::inherit_node::InheritNode;
use crate::ast::int_node::IntNode;
use crate::ast::labeled_statement_node::LabeledStatementNode;
use crate::ast::label_node::LabelNode;
use crate::ast::mapping_node::MappingNode;
use crate::ast::program_node::ProgramNode;
use crate::ast::range_node::RangeNode;
use crate::ast::return_node::ReturnNode;
use crate::ast::string_node::StringNode;
use crate::ast::switch_node::SwitchNode;
use crate::ast::ternary_node::TernaryNode;
use crate::ast::unary_op_node::{UnaryOpNode, UnaryOperation};
use crate::ast::var_node::VarNode;
use crate::ast::var_init_node::VarInitNode;
use crate::ast::while_node::WhileNode;
use crate::core::lpc_type::LpcType;
use crate::core::call_namespace::CallNamespace;
use crate::core::EFUN;
use crate::parser::collapse_binary_op::collapse_binary_op;
use crate::parser::collapse_unary_op::collapse_unary_op;
use crate::parser::span::{Span, combine_spans};
use crate::parser::lexer::Token;
use crate::errors::LpcError;
use crate::parser::lexer::logos_token::{StringToken, IntToken, FloatToken};
use crate::LpcFloat;
use crate::compilation_context::CompilationContext;
use crate::semantic::function_flags::FunctionFlags;
use crate::semantic::global_var_flags::GlobalVarFlags;

grammar<'context>(context: &'context CompilationContext);

extern {
    type Location = usize;
    type Error = LpcError;

    enum Token {
        "+" => Token::Plus(<Span>),
        "-" => Token::Minus(<Span>),
        "*" => Token::Mul(<Span>),
        "/" => Token::Div(<Span>),
        "%" => Token::Mod(<Span>),
        "!" => Token::Bang(<Span>),
        "^" => Token::Caret(<Span>),
        "~" => Token::Tilde(<Span>),
        "&" => Token::And(<Span>),
        "&&" => Token::AndAnd(<Span>),
        "|" => Token::Or(<Span>),
        "||" => Token::OrOr(<Span>),
        "<<" => Token::LeftShift(<Span>),
        ">>" => Token::RightShift(<Span>),
        "==" => Token::EqEq(<Span>),
        "!=" => Token::NotEq(<Span>),
        "<" => Token::LessThan(<Span>),
        "<=" => Token::LessThanEq(<Span>),
        ">" => Token::GreaterThan(<Span>),
        ">=" => Token::GreaterThanEq(<Span>),
        "++" => Token::Inc(<Span>),
        "--" => Token::Dec(<Span>),

        "=" => Token::Assign(<Span>),
        "+=" => Token::AddEq(<Span>),
        "-=" => Token::SubEq(<Span>),
        "*=" => Token::MulEq(<Span>),
        "/=" => Token::DivEq(<Span>),
        "%=" => Token::ModEq(<Span>),
        "^=" => Token::CaretEq(<Span>),
        "&=" => Token::AndEq(<Span>),
        "&&=" => Token::AndAndEq(<Span>),
        "|=" => Token::OrEq(<Span>),
        "||=" => Token::OrOrEq(<Span>),
        "<<=" => Token::LeftShiftEq(<Span>),
        ">>=" => Token::RightShiftEq(<Span>),

        "if" => Token::If(<Span>),
        "else" => Token::Else(<Span>),
        "while" => Token::While(<Span>),
        "for" => Token::For(<Span>),
        "foreach" => Token::ForEach(<Span>),
        "inherit" => Token::Inherit(<Span>),
        "break" => Token::Break(<Span>),
        "continue" => Token::Continue(<Span>),
        "case" => Token::Case(<Span>),
        "do" => Token::Do(<Span>),
        "int" => Token::Int(<Span>),
        "float" => Token::Float(<Span>),
        "string" => Token::String(<Span>),
        "object" => Token::Object(<Span>),
        "mapping" => Token::Mapping(<Span>),
        "mixed" => Token::Mixed(<Span>),
        "function" => Token::Function(<Span>),
        "void" => Token::Void(<Span>),
        "return" => Token::Return(<Span>),
        "public" => Token::Public(<Span>),
        "private" => Token::Private(<Span>),
        "protected" => Token::Protected(<Span>),
        "static" => Token::Static(<Span>),
        "varargs" => Token::Varargs(<Span>),
        "nomask" => Token::Nomask(<Span>),
        "efun" => Token::Efun(<Span>),
        "switch" => Token::Switch(<Span>),
        "default" => Token::Default(<Span>),

        "(" => Token::LParen(<Span>),
        ")" => Token::RParen(<Span>),
        "[" => Token::LBracket(<Span>),
        "]" => Token::RBracket(<Span>),
        "{" => Token::LBrace(<Span>),
        "}" => Token::RBrace(<Span>),
        "," => Token::Comma(<Span>),
        "->" => Token::CallOther(<Span>),
        "?" => Token::Question(<Span>),
        ":" => Token::Colon(<Span>),
        "::" => Token::ColonColon(<Span>),
        ";" => Token::Semi(<Span>),
        "..." => Token::Ellipsis(<Span>),
        ".." => Token::Range(<Span>),

        "StringLiteral" => Token::StringLiteral(<StringToken>),
        "IntLiteral" => Token::IntLiteral(<IntToken>),
        "FloatLiteral" => Token::FloatLiteral(<FloatToken>),
        "ID" => Token::Id(<StringToken>),
    }
}

pub Program: ProgramNode = <inherits:Inherit*> <body:Def*> => ProgramNode {
    inherits,
    body: body.into_iter().map(|i| AstNode::from(i)).collect::<Vec<_>>()
};

pub Inherit: InheritNode = {
    <l:"inherit"> <path_node:String> <namespace:"ID"?> <r:";"> =>? {
        let span = combine_spans(Some(l), Some(r));

        let path = if let ExpressionNode::String(StringNode { value, .. }) = path_node {
            value
        } else {
            let error = LpcError::new("Inherit path isn't a string? This should not have even parsed.")
            .with_span(Some(span));

            return Err(ParseError::User { error });
        };

        Ok(
            InheritNode {
                path,
                namespace: namespace.map(|ns| ns.1),
                span: Some(span),
            }
        )
    }
};

pub Def: AstNode = {
    <FunctionDef> => AstNode::from(<>),
    <flags:GlobalFlag*> <mut node:Decl> ";" =>? {
        let flag_strs = flags.iter().map(|i| i.0).collect::<Vec<_>>();
        let invalid = GlobalVarFlags::validate(&flag_strs);
        if let Some(field) = invalid.first() {
            let span = combine_spans(Some(flags[0].1), Some(flags.last().unwrap().1));

            let err = LpcError::new(format!("`{}` is intended for functions only", field))
                                      .with_span(Some(span));
            return Err(ParseError::User { error: err });
        }

        let flags = GlobalVarFlags::from(flag_strs);

        node.initializations.iter_mut().for_each(|i| {
            i.global = true;
            i.flags = Some(flags);
        });

        Ok(AstNode::from(node))
    }
};

pub FunctionDef: FunctionDefNode = {
    <flags:GlobalFlag*> <r_type:Type?> <star:"*"?> <name:"ID"> <parameter_tuple:Parameters> "{" <body:Statements> "}" =>? {
        let array = star.is_some();
        let (parameters, ellipsis) = parameter_tuple;

        let l = if flags.len() > 0 {
            flags.first().unwrap().1.l
        } else if let Some((_, span)) = &r_type {
            span.l
        } else if let Some(span) = &star {
            span.l
        } else {
            name.0.l
        };

        let r = name.0.r;
        let file_id = name.0.file_id;

        let span = Span::new(file_id, l..r);

        let return_type = if let Some(this_type) = r_type {
            LpcType::from(this_type.0).as_array(array)
        } else if context.pragmas.strict_types() {
            let err = LpcError::new("Missing return type")
                                      .with_span(Some(span))
                                      .with_note("`#pragma strict_types` is enabled, which requires all functions to have an explicit return type.");
            return Err(ParseError::User { error: err });
        } else {
            LpcType::Mixed(array)
        };

        let flag_strs = flags.into_iter().map(|f| f.0).collect::<Vec<_>>();
        if flag_strs.iter().filter(|f| ["public", "private", "protected", "static"].contains(f)).count() > 1 {
            let err = LpcError::new(
                "multiple visibilities specified. use one of `public`, `private`, or `protected`, or leave unspecified for `public` visibility".to_string()
            ).with_span(Some(span));

            return Err(ParseError::User { error: err });
        }
        let flags = FunctionFlags::from(flag_strs).with_ellipsis(ellipsis);
        // if !flags.public() && !flags.private() && !flags.protected() {
        //     flags.set_public(true);
        // }

        Ok(FunctionDefNode {
            name: name.1,
            parameters,
            flags,
            body,
            return_type,
            span: Some(span)
        })
    },
}

Parameters: (Vec<VarInitNode>, bool) = {
    "(" ")" => {
        (Vec::new(), false)
    },
    "(" <params:ParameterList> <ellipsis:("," "...")?> ")" => {
        (params, ellipsis.is_some())
    },
    "(" "..." ")" => {
        (Vec::new(), true)
    }
};

ParameterList: Vec<VarInitNode> = {
    <list:(<ParameterList> ",")?> <name:ArgName> => {
        let mut v = list.unwrap_or(vec![]);
        v.push(name);
        v
    }
};

ArgName: VarInitNode = {
    <var_type:Type> <mut init:VarInit> => {
        let new_type = LpcType::from(var_type.0);

        init.type_ = new_type.as_array(init.array);

        init
    }
};

// TODO: flip the order of these so they match tokens
Type: (&'static str, Span) = {
    "int" => ("int", <>),
    "float" => ("float", <>),
    "string" => ("string", <>),
    "mixed" => ("mixed", <>),
    "mapping" => ("mapping", <>),
    "object" => ("object", <>),
    "function" => ("function", <>),
    "void" => ("void", <>),
};

// TODO: flip the order of these so they match tokens
GlobalFlag: (&'static str, Span) = {
    "varargs" => ("varargs", <>),
    "public" => ("public", <>),
    "private" => ("private", <>),
    "static" => ("static", <>),
    "protected" => ("protected", <>),
    "nomask" => ("nomask", <>),
};

pub Statement: AstNode = {
    <OpenStatement>,
    <ClosedStatement>,
};

pub Statements: Vec<AstNode> = {
    <Statement*>
};

pub ExpressionStatement: Option<ExpressionNode> = {
    <Expression?> ";"
}

pub SimpleStatement: AstNode = {
    <Expression> ";" => AstNode::from(<>),
    <Return> ";" => AstNode::from(<>),
    <Decl> ";" => AstNode::from(<>),
    <Block> => AstNode::from(<>),
    <DoWhile> => AstNode::from(<>),
    <JumpStatement>
};

JumpStatement: AstNode = {
    <span:"break"> ";" => {
        let n = BreakNode { span: Some(span) };
        AstNode::from(n)
    },
    <span:"continue"> ";" => {
        let n = ContinueNode { span: Some(span) };
        AstNode::from(n)
    }
};

OpenStatement: AstNode = {
    <if_t:"if"> "(" <cond:Expression> ")" <body:Statement> => {
        // https://github.com/lalrpop/lalrpop/issues/67#issuecomment-188951041
        let node = IfNode::new(cond, body, None, Some(if_t));
        AstNode::from(node)
    },
    <if_t:"if"> "(" <cond:Expression> ")" <body:ClosedStatement> "else" <else_clause:OpenStatement> => {
        let node = IfNode::new(cond, body, Some(else_clause), Some(if_t));
        AstNode::from(node)
    },
    <while_t:"while"> "(" <cond:Expression> ")" <body:OpenStatement> => {
        let node = WhileNode::new(cond, body, Some(while_t));
        AstNode::from(node)
    },
    <for_t:"for"> "(" <init:ForInit?> ";" <cond:Expression?> ";" <inc:Expression?> ")" <body:OpenStatement> => {
        let node = ForNode::new(init, cond, inc, body, Some(for_t));
        AstNode::from(node)
    },
    <foreach_t:"foreach"> "(" <init:ForEachInit> ":" <collection:Expression> ")" <body:OpenStatement> => {
        let node = ForEachNode::new(init, collection, body, Some(foreach_t));
        AstNode::from(node)
    },
    <l:"switch"> "(" <expression:Expression> <r:")"> <body:OpenStatement> => {
        let span = combine_spans(Some(l), Some(r));
        let node = SwitchNode {
            expression,
            body: body.into(),
            span: Some(l),
        };
        AstNode::from(node)
    },
    <label:Label> <statement:OpenStatement> => {
        let labeled = LabeledStatementNode::new(statement, label);
        AstNode::from(labeled)
    }
};

ClosedStatement: AstNode = {
    <SimpleStatement>,
    <if_t:"if"> "(" <cond:Expression> ")" < body:ClosedStatement> "else" <else_clause:ClosedStatement> => {
        let node = IfNode::new(cond, body, Some(else_clause), Some(if_t));
        AstNode::from(node)
    },
    <while_t:"while"> "(" <cond:Expression> ")" <body:ClosedStatement> => {
        let node = WhileNode::new(cond, body, Some(while_t));
        AstNode::from(node)
    },
    <for_t:"for"> "(" <init:ForInit?> ";" <cond:Expression?> ";" <inc:Expression?> ")" <body:ClosedStatement> => {
        let node = ForNode::new(init, cond, inc, body, Some(for_t));
        AstNode::from(node)
    },
    <foreach_t:"foreach"> "(" <init:ForEachInit> ":" <collection:Expression> ")" <body:ClosedStatement> => {
        let node = ForEachNode::new(init, collection, body, Some(foreach_t));
        AstNode::from(node)
    },
    <l:"switch"> "(" <expression:Expression> <r:")"> <body:ClosedStatement> => {
        let span = combine_spans(Some(l), Some(r));
        let node = SwitchNode {
            expression,
            body: body.into(),
            span: Some(l),
        };
        AstNode::from(node)
    },
    <label:Label> <statement:ClosedStatement> => {
        let labeled = LabeledStatementNode::new(statement, label);
        AstNode::from(labeled)
    }
};

ForInit: AstNode = {
    <Decl> => AstNode::from(<>),
    <Expression> => AstNode::from(<>)
};

ForEachInit: ForEachInit = {
    <ty:Type> <name:"ID"> => {
        let span = combine_spans(Some(ty.1), Some(name.0));
        let mut node = VarInitNode::new(&name.1, LpcType::from(ty.0));
        node.span = Some(span);
        
        ForEachInit::Array(node)
    },
    <key_type:Type> <key_name:"ID"> "," <value_type:Type> <value_name:"ID"> => {
        let key_span = combine_spans(Some(key_type.1), Some(key_name.0));
        let mut key = VarInitNode::new(&key_name.1, LpcType::from(key_type.0));
        key.span = Some(key_span);

        let value_span = combine_spans(Some(value_type.1), Some(value_name.0));
        let mut value = VarInitNode::new(&value_name.1, LpcType::from(value_type.0));
        value.span = Some(value_span);
        
        ForEachInit::Mapping { key, value }
    },
};

DoWhile: DoWhileNode = {
    <do_t:"do"> <body:Statement> "while" "(" <cond:Expression> ")" ";" => {
        DoWhileNode::new(body, cond, Some(do_t))
    }
};

Label: LabelNode = {
    <word:"case"> <case:SwitchCase> <colon:":"> => {
        let span = combine_spans(Some(word), Some(colon));
        LabelNode::new(case, Some(span))
    },
    <d:"default"> ":" => {
        LabelNode::new_default(Some(d))
    }
};

SwitchCase: ExpressionNode = {
    <Expression>,
    <e1:ConditionalExpression> ".." <e2:ConditionalExpression> => {
        let span = combine_spans(e1.span(), e2.span());
        RangeNode::new(Some(e1), Some(e2), Some(span)).into()
    },
    <rng:".."> <e:ConditionalExpression> => {
        let span = combine_spans(Some(rng), e.span());
        RangeNode::new(None, Some(e), Some(span)).into()
    },
    <e:ConditionalExpression> <rng:".."> => {
        let span = combine_spans(e.span(), Some(rng));
        RangeNode::new(Some(e), None, Some(span)).into()
    },
};

VarInit: VarInitNode = {
    <array:"*"?> <name:"ID"> <value:("=" <AssignmentExpression>)?> => {
        let name_span = name.0;
        let file_id = name_span.file_id;
        let l = array.unwrap_or(name_span).l;
        let r = value
                    .as_ref()
                    .map(|node| node.span())
                    .flatten()
                    .unwrap_or(name_span)
                    .r;

        VarInitNode {
            type_: LpcType::Int(false), // placeholder. Corrected in Decl.
            name: name.1,
            value,
            array: array.is_some(),
            global: false,
            span: Some(Span::new(file_id, l..r)),
            flags: None,
        }
    }
}

pub Decl: DeclNode = {
    <var_type:Type> <init:VarInit> <optional:("," <VarInit>)*> => {
        let new_type = LpcType::from(var_type.0).as_array(init.array);
        let mut initializations = vec![init];

        initializations.append(optional.to_vec().as_mut());

        // Update each VarInitNode with the correct type.
        for init in &mut initializations {
            init.update_type(new_type)
        }

        DeclNode {
            type_: new_type,
            initializations
        }
    }
}

pub Block: BlockNode = {
    "{" <Statements> "}" => {
        BlockNode::new(<>)
    }
};

pub PrimaryExpression: ExpressionNode = {
    <Int>,
    <Float>,
    <String>,
    <Var>,
    <FunctionPointer>,
    "(" <Expression> ")",
    "(" "{" <l:(ExpressionList ","?)?>  "}" ")" => {
        let vec = l.map(|list| list.0).unwrap_or_else(|| Vec::new());

        ExpressionNode::Array(ArrayNode::new(vec))
    },
    <l:"("> "[" <list:(MappingExpressionList ","?)?> "]" <r:")"> => {
        let vec = if let Some(v) = list {
            // Deduplicate kv pairs, in reverse so later-declared pairs override earlier ones.
            let reversed = v.0.into_iter().rev().unique_by(|(k, _)| k.to_string()).collect_vec();

            // We have to `collect` twice because `unique_by` keeps the first duplicate, but we want
            // to keep the last, and doing a second `rev()` in a single iterator chain applies it
            // before the `unique_by` runs
            reversed.into_iter().rev().collect_vec()
        } else {
            Vec::new()
        };

        let span = Span {
            r: r.r,
            ..l
        };

        ExpressionNode::Mapping(MappingNode::new(vec, Some(span)))
    }
};

pub PostfixExpression: ExpressionNode = {
    <PrimaryExpression>,
    <l:PostfixExpression> "[" <r:Expression> <right:"]"> =>? {
        let file_id = first_span(&[&l, &r]).file_id;
        let left = l.span().map(|s| s.l).unwrap_or(0);

        collapse_binary_op(BinaryOperation::Index, l, r, Span { file_id, l: left, r: right.r })
    },
    <l:PostfixExpression> "["  <e1:Expression> ".." <e2:Expression> <right:"]"> =>? {
        let file_id = first_span(&[&l, &e1, &e2]).file_id;
        let left = l.span().map(|s| s.l).unwrap_or(0);

        let r = ExpressionNode::Range(RangeNode {
            l: Box::new(Some(e1)),
            r: Box::new(Some(e2)),
            span: Some(Span { file_id, l: left, r: right.r })
        });

        collapse_binary_op(BinaryOperation::Index, l, r, Span { file_id, l: left, r: right.r })
    },
    <l:PostfixExpression> "[" ".." <e:Expression> <right:"]"> =>? {
        let file_id = first_span(&[&l, &e]).file_id;
        let left = l.span().map(|s| s.l).unwrap_or(0);

        let r = ExpressionNode::Range(RangeNode {
            l: Box::new(None),
            r: Box::new(Some(e)),
            span: Some(Span { file_id, l: left, r: right.r })
        });

        collapse_binary_op(BinaryOperation::Index, l, r, Span { file_id, l: left, r: right.r })
    },
    <l:PostfixExpression> "[" <e:Expression> ".." <right:"]"> =>? {
        let file_id = first_span(&[&l, &e]).file_id;
        let left = l.span().map(|s| s.l).unwrap_or(0);

        let r = ExpressionNode::Range(RangeNode {
            l: Box::new(Some(e)),
            r: Box::new(None),
            span: Some(Span { file_id, l: left, r: right.r })
        });

        collapse_binary_op(BinaryOperation::Index, l, r, Span { file_id, l: left, r: right.r })
    },
    <e:(<PostfixExpression> "->")?> <mut c:Call> => {
        if let Some(rcvr) = e {
            let span = Span::combine(rcvr.span(), c.span);
            c.receiver = Some(Box::new(rcvr));
            c.span = span;

            ExpressionNode::from(c)
        } else {
            ExpressionNode::from(c)
        }
    },
    <PostfixExpression> "++" => {
        let span = <>.span();
        let n = UnaryOpNode {
            expr: Box::new(<>),
            op: UnaryOperation::Inc,
            is_post: true,
            span
        };

        collapse_unary_op(n)
    },
    <PostfixExpression> "--" => {
        let span = <>.span();
        let n = UnaryOpNode {
            expr: Box::new(<>),
            op: UnaryOperation::Dec,
            is_post: true,
            span
        };

        collapse_unary_op(n)
    },
};

pub UnaryExpression: ExpressionNode = {
    <PostfixExpression>,
    <op:UnaryOp> <expr:CastExpression> => {
        let span = expr.span().map(|s| {
            Span {
                l: op.1.start,
                ..s
            }
        });

        let n = UnaryOpNode {
            expr: Box::new(expr),
            op: op.0,
            is_post: false,
            span
        };

        collapse_unary_op(n)
    }
};

pub CastExpression: ExpressionNode = {
    <UnaryExpression>,
}

pub MultiplicitiveExpression: ExpressionNode = {
    <CastExpression>,
    <l:MultiplicitiveExpression> <op:MultiplicitiveBinaryOp> <r:CastExpression> =>? {
        let span = combine_spans(l.span(), r.span());

        collapse_binary_op(op, l, r, span)
    },
};

pub AdditiveExpression: ExpressionNode = {
    <MultiplicitiveExpression>,
    <l:AdditiveExpression> <op:AdditiveBinaryOp> <r:MultiplicitiveExpression> =>? {
        let span = combine_spans(l.span(), r.span());

        collapse_binary_op(op, l, r, span)
    }
};

pub ShiftExpression: ExpressionNode = {
    <AdditiveExpression>,
    <l:ShiftExpression> <op:ShiftOp> <r:AdditiveExpression> =>? {
        let span = combine_spans(l.span(), r.span());

        collapse_binary_op(op, l, r, span)
    }
};

pub RelationalExpression: ExpressionNode = {
    <ShiftExpression>,
    <l:RelationalExpression> <op:RelationalOp> <r:ShiftExpression> =>? {
        let span = combine_spans(l.span(), r.span());

        collapse_binary_op(op, l, r, span)
    }
};

pub EqualityExpression: ExpressionNode = {
    <RelationalExpression>,
    <l:EqualityExpression> <op:EqualityOp> <r:RelationalExpression> =>? {
        let span = combine_spans(l.span(), r.span());

        collapse_binary_op(op, l, r, span)
    }
};

pub AndExpression: ExpressionNode = {
    <EqualityExpression>,
    <l:AndExpression> "&" <r:EqualityExpression> =>? {
        let span = combine_spans(l.span(), r.span());

        collapse_binary_op(BinaryOperation::And, l, r, span)
    }
};

pub ExclusiveOrExpression: ExpressionNode = {
    <AndExpression>,
    <l:ExclusiveOrExpression> "^" <r:AndExpression> =>? {
        let span = combine_spans(l.span(), r.span());

        collapse_binary_op(BinaryOperation::Xor, l, r, span)
    }
};

pub OrExpression: ExpressionNode = {
    <ExclusiveOrExpression>,
    <l:OrExpression> "|" <r:ExclusiveOrExpression> =>? {
        let span = combine_spans(l.span(), r.span());

        collapse_binary_op(BinaryOperation::Or, l, r, span)
    }
};

pub LogicalAndExpression: ExpressionNode = {
    <OrExpression>,
    <l:LogicalAndExpression> "&&" <r:OrExpression> =>? {
        let span = combine_spans(l.span(), r.span());

        collapse_binary_op(BinaryOperation::AndAnd, l, r, span)
    }
};

pub LogicalOrExpression: ExpressionNode = {
    <LogicalAndExpression>,
    <l:LogicalOrExpression> "||" <r:LogicalAndExpression> =>? {
        let span = combine_spans(l.span(), r.span());

        collapse_binary_op(BinaryOperation::OrOr, l, r, span)
    }
};

pub ConditionalExpression: ExpressionNode = {
    <LogicalOrExpression>,
    <cond:LogicalOrExpression> "?" <body:Expression> ":" <else_clause:ConditionalExpression> => {
        let file_id = first_span(&[&cond, &body, &else_clause]).file_id;
        let l = cond.span().map(|s| s.l).unwrap_or(0);
        let r = else_clause.span().map(|s| s.r).unwrap_or(0);

        ExpressionNode::from(TernaryNode::new(cond, body, else_clause, Some(Span { file_id, l, r })))
    }
};

pub AssignmentExpression: ExpressionNode = {
    <ConditionalExpression>,
    <lhs:UnaryExpression> <op:AssignmentOp> <rhs:AssignmentExpression> => {
        let span = combine_spans(lhs.span(), rhs.span());

        // Desugar `op=` operators (e.g. `x += y`, etc.) into `x = x op y`
        let rhs = match op {
            AssignmentOperation::Simple => {
                rhs
            }
            AssignmentOperation::AddEq
            | AssignmentOperation::AndAndEq
            | AssignmentOperation::AndEq
            | AssignmentOperation::DivEq
            | AssignmentOperation::ModEq
            | AssignmentOperation::MulEq
            | AssignmentOperation::OrEq
            | AssignmentOperation::OrOrEq
            | AssignmentOperation::ShlEq
            | AssignmentOperation::ShrEq
            | AssignmentOperation::SubEq
            | AssignmentOperation::XorEq => {
                let binary_op = match BinaryOperation::try_from(op) {
                    Ok(x) => x,
                    Err(_) => unreachable!("This only way for this to be reached is if a new op was added in the parent `match`, without updating the TryFrom implementation, which shouldn't compile.")
                };

                ExpressionNode::BinaryOp(BinaryOpNode {
                    op: binary_op,
                    span: rhs.span(),
                    l: Box::new(lhs.clone()),
                    r: Box::new(rhs),
                })

            }
            _ => panic!("unknown operation in assignment: `{}`", op)
        };

        ExpressionNode::Assignment(AssignmentNode {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            span: Some(span),
        })
    }
};

pub Expression: ExpressionNode = {
    <AssignmentExpression>,
    <e:Expression> <c:","> <ass:AssignmentExpression> => {
        let file_id = if let Some(s) = e.span() {
            s.file_id
        } else if let Some(s) = ass.span() {
            s.file_id
        } else {
            c.file_id
        };

        let l = e.span().unwrap_or(c).l;
        let r = ass.span().unwrap_or(c).r;

        let mut list = if let ExpressionNode::CommaExpression(ce) = e {
            ce.value
        } else {
            vec![e]
        };

        list.extend_from_slice(&[ass]);

        ExpressionNode::CommaExpression(CommaExpressionNode {
            value: list,
            span: Some(Span { file_id, l, r })
        })
    }
};

pub Return: ReturnNode = {
    <ret:"return"> <e:Expression?> => {
        let r = if let Some(expr) = &e {
            expr.span().unwrap_or(ret).r
        } else {
            ret.r
        };

        ReturnNode { value: e, span: Some(Span { file_id: ret.file_id, l: ret.l, r }) }
    }
}

ExpressionList: Vec<ExpressionNode> = {
    <AssignmentExpression> => vec![<>],
    <list:ExpressionList> "," <arg:AssignmentExpression> => {
        let mut v = list;
        v.push(arg);
        v
    }
};

ArgumentExpressionList: Vec<ExpressionNode> = {
    <AssignmentExpression> => vec![<>],
    <list:ArgumentExpressionList> "," <arg:AssignmentExpression> => {
        let mut v = list;
        v.push(arg);
        v
    }
};

MappingExpressionList: Vec<(ExpressionNode, ExpressionNode)> = {
    <MappingInitializer> => {
        vec![(<>.0, <>.1)]
    },
    <vec:MappingExpressionList> "," <arg:MappingInitializer> => {
        let mut v = vec;
        v.push((arg.0, arg.1));
        v
    }
};

MappingInitializer: (ExpressionNode, ExpressionNode) = {
    <a:AssignmentExpression> ":" <b:AssignmentExpression> => {
        (a, b)
    }
}

pub Call: CallNode = {
    <ns:CallNamespace?> <name:"ID"> "(" <list:ArgumentExpressionList?> <right:")"> => {
        let arguments = list.unwrap_or_else(|| Vec::new());

        let (left, namespace) = ns.unwrap_or_else(|| (name.0, CallNamespace::default()));
        let file_id = left.file_id;
        let l = left.l;
        let r = right.r;

        CallNode {
            receiver: None,
            arguments,
            name: name.1,
            span: Some(Span { file_id, l, r }),
            namespace
        }
    }
};

CallNamespace: (Span, CallNamespace) = {
    <name:"ID"?> <colons:"::"> => {
        name.map(|nm| (nm.0, CallNamespace::Named(nm.1)))
            .unwrap_or_else(|| (colons, CallNamespace::Parent))
    },
    <name:"efun"> <colons:"::"> => (name, CallNamespace::Named(EFUN.to_string()))
};

AssignmentOp: AssignmentOperation = {
    "=" => AssignmentOperation::Simple,
    "+=" => AssignmentOperation::AddEq,
    "-=" => AssignmentOperation::SubEq,
    "*=" => AssignmentOperation::MulEq,
    "/=" => AssignmentOperation::DivEq,
    "&&=" => AssignmentOperation::AndAndEq,
    "||=" => AssignmentOperation::OrOrEq,
    "&=" => AssignmentOperation::AndEq,
    "|=" => AssignmentOperation::OrEq,
    "<<=" => AssignmentOperation::ShlEq,
    ">>=" => AssignmentOperation::ShrEq,
};

AdditiveBinaryOp: BinaryOperation = {
    "+" => BinaryOperation::Add,
    "-" => BinaryOperation::Sub
};

MultiplicitiveBinaryOp: BinaryOperation = {
    "%" => BinaryOperation::Mod,
    "*" => BinaryOperation::Mul,
    "/" => BinaryOperation::Div
};

EqualityOp: BinaryOperation = {
    "==" => BinaryOperation::EqEq,
};

RelationalOp: BinaryOperation = {
    "<" => BinaryOperation::Lt,
    "<=" => BinaryOperation::Lte,
    ">" => BinaryOperation::Gt,
    ">=" => BinaryOperation::Gte,
};

ShiftOp: BinaryOperation = {
    "<<" => BinaryOperation::Shl,
    ">>" => BinaryOperation::Shr,
};

UnaryOp: (UnaryOperation, Range<usize>) = {
    <l:@L> "-" <r:@R> => (UnaryOperation::Negate, l..r),
    <l:@L> "++" <r:@R> => (UnaryOperation::Inc, l..r),
    <l:@L> "--" <r:@R> => (UnaryOperation::Dec, l..r),
    <l:@L> "!" <r:@R> => (UnaryOperation::Bang, l..r),
    <l:@L> "~" <r:@R> => (UnaryOperation::BitwiseNot, l..r),
}

Var: ExpressionNode = <name:"ID"> => {
    ExpressionNode::Var(
        VarNode {
            name: name.1,
            span: Some(name.0),
            global: false,
            function_name: false,
        }
    )
};

Int: ExpressionNode = {
    <i:"IntLiteral"> => {
        ExpressionNode::Int(
            IntNode {
                value: i.1,
                span: Some(i.0),
            }
        )
    },
};

Float: ExpressionNode = <f:"FloatLiteral"> => {
    ExpressionNode::Float(
        FloatNode {
            value: LpcFloat::from(f.1),
            span: Some(f.0)
        }
    )
};

String: ExpressionNode = {
    <s:"StringLiteral"> => {
        ExpressionNode::String(
            StringNode {
                value: s.1,
                span: Some(s.0)
            }
        )
    },
    <s1:"StringLiteral"> <s2:String> => {
        let span = s1.0;
        let file_id = span.file_id;
        let l = span.l;

        match s2 {
            ExpressionNode::String(node) => {
                let r = node.span.map(|s| s.r).unwrap_or(l);
                ExpressionNode::String(StringNode {
                    value: s1.1 + &node.value,
                    span: Some(Span { file_id, l, r })
                })
            }
            _ => unimplemented!()
        }
    },
};

FunctionPointer: ExpressionNode = {
    <l:"&"> <receiver:FunctionPointerReceiver?> <mut name:"ID"> "(" <arguments:PartialArgumentExpressionList?> <r:")"> => {
        let ptr_node = FunctionPtrNode {
            receiver,
            arguments,
            name: std::mem::take(&mut name.1),
            span: Some(combine_spans(Some(l), Some(r)))
        };

        ExpressionNode::from(ptr_node)
    }
};

FunctionPointerReceiver: FunctionPtrReceiver = {
    "(" <expr:PostfixExpression> ")" "->" => FunctionPtrReceiver::Static(Box::new(expr)),
    "->" => FunctionPtrReceiver::Dynamic,
};

PartialArgumentExpressionList: Vec<Option<ExpressionNode>> = {
    <AssignmentExpression> => vec![Some(<>)],
    <list:PartialArgumentExpressionList?> "," <arg:AssignmentExpression?> => {
        let mut v = list.unwrap_or_else(|| vec![None]);

        v.push(arg);
        v
    },
};
