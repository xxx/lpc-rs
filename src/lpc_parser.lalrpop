use crate::ast::program_node::ProgramNode;
use crate::ast::binary_op_node::BinaryOperation;
use crate::ast::expression_node::{ExpressionNode, first_span};
use crate::ast::function_def_node::FunctionDefNode;
use crate::ast::int_node::IntNode;
use crate::ast::float_node::FloatNode;
use crate::ast::call_node::CallNode;
use crate::ast::return_node::ReturnNode;
use crate::ast::decl_node::DeclNode;
use crate::ast::var_init_node::VarInitNode;
use crate::ast::range_node::RangeNode;
use crate::ast::var_node::VarNode;
use crate::ast::string_node::StringNode;
use crate::ast::assignment_node::{AssignmentOperation, AssignmentNode};
use crate::ast::array_node::ArrayNode;
use crate::ast::comma_expression_node::CommaExpressionNode;
use crate::semantic::lpc_type::LPCType;
use crate::ast::ast_node::{ASTNode, SpannedNode};
use crate::parser::collapse_expression::collapse_expression;
use crate::parser::span::Span;
use crate::parser::lexer::Token;
use crate::errors::compiler_error::lex_error::LexError;
use crate::parser::lexer::logos_token::{StringToken, IntToken, FloatToken};

grammar;

extern {
    type Location = usize;
    type Error = LexError;

    enum Token {
        "+" => Token::Plus(<Span>),
        "-" => Token::Minus(<Span>),
        "*" => Token::Mul(<Span>),
        "/" => Token::Div(<Span>),
        "%" => Token::Mod(<Span>),
        "!" => Token::Bang(<Span>),
        "^" => Token::Caret(<Span>),
        "~" => Token::Tilde(<Span>),
        "&" => Token::And(<Span>),
        "&&" => Token::AndAnd(<Span>),
        "|" => Token::Or(<Span>),
        "||" => Token::OrOr(<Span>),
        "<<" => Token::LeftShift(<Span>),
        ">>" => Token::RightShift(<Span>),
        "==" => Token::EqEq(<Span>),
        "!=" => Token::NotEq(<Span>),
        "<" => Token::LessThan(<Span>),
        "<=" => Token::LessThanEq(<Span>),
        ">" => Token::GreaterThan(<Span>),
        ">=" => Token::GreaterThanEq(<Span>),

        "=" => Token::Assign(<Span>),
        "+=" => Token::PlusEq(<Span>),
        "-=" => Token::MinusEq(<Span>),
        "*=" => Token::MulEq(<Span>),
        "/=" => Token::DivEq(<Span>),
        "%=" => Token::ModEq(<Span>),
        "^=" => Token::CaretEq(<Span>),
        "~=" => Token::TildeEq(<Span>),
        "&=" => Token::AndEq(<Span>),
        "&&=" => Token::AndAndEq(<Span>),
        "|=" => Token::OrEq(<Span>),
        "||=" => Token::OrOrEq(<Span>),
        "<<=" => Token::LeftShiftEq(<Span>),
        ">>=" => Token::RightShiftEq(<Span>),

        "if" => Token::If(<Span>),
        "else" => Token::Else(<Span>),
        "while" => Token::While(<Span>),
        "for" => Token::For(<Span>),
        "inherit" => Token::Inherit(<Span>),
        "break" => Token::Break(<Span>),
        "continue" => Token::Continue(<Span>),
        "case" => Token::Case(<Span>),
        "do" => Token::Do(<Span>),
        "int" => Token::Int(<Span>),
        "float" => Token::Float(<Span>),
        "string" => Token::String(<Span>),
        "object" => Token::Object(<Span>),
        "mapping" => Token::Mapping(<Span>),
        "mixed" => Token::Mixed(<Span>),
        "void" => Token::Void(<Span>),
        "return" => Token::Return(<Span>),
        "static" => Token::Static(<Span>),
        "nomask" => Token::Nomask(<Span>),
        "efun" => Token::Efun(<Span>),

        "(" => Token::LParen(<Span>),
        ")" => Token::RParen(<Span>),
        "[" => Token::LBracket(<Span>),
        "]" => Token::RBracket(<Span>),
        "{" => Token::LBrace(<Span>),
        "}" => Token::RBrace(<Span>),
        "," => Token::Comma(<Span>),
        "->" => Token::CallOther(<Span>),
        "?" => Token::Question(<Span>),
        ":" => Token::Colon(<Span>),
        "::" => Token::ColonColon(<Span>),
        ";" => Token::Semi(<Span>),
        "..." => Token::Ellipsis(<Span>),
        ".." => Token::Range(<Span>),

        "StringLiteral" => Token::StringLiteral(<StringToken>),
        "IntLiteral" => Token::IntLiteral(<IntToken>),
        "FloatLiteral" => Token::FloatLiteral(<FloatToken>),
        "ID" => Token::ID(<StringToken>),
    }
}

SemiSeq<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Program: ProgramNode = <body:Def*> => ProgramNode {
    body: body.iter().map(|i| ASTNode::from(i.clone())).collect::<Vec<_>>()
};

pub Def: ASTNode = {
    <FunctionDef> => ASTNode::from(<>),
    <decl:Decl> ";" => {
        let mut node = decl.clone();
        node.initializations.iter_mut().for_each(|i| i.global = true);

        ASTNode::from(node)
    }
};

FunctionDef: FunctionDefNode = {
    <r_type:Type?> <star:"*"?> <name:"ID"> <parameters:Parameters> "{" <body:SemiSeq<Statement>> "}" => {
        let array = star.is_some();

        let l = if let Some((_, span)) = &r_type {
           span.l
        } else if let Some(span) = &star {
           span.l
        } else {
           name.0.l
        };

        let r = name.0.r;

         let return_type = if let Some(this_type) = r_type {
             match this_type.0.as_str() {
                 "void" => LPCType::Void,
                 "int" => LPCType::Int(array),
                 "string" => LPCType::String(array),
                 "float" => LPCType::Float(array),
                 // "object" => LPCType::Object(array),
                 // "mapping" => LPCType::Mapping(array),
                 "mixed" => LPCType::Mixed(array),
                 _ => unimplemented!()
             }
         } else {
             LPCType::Int(array)
         };

        let file_id = name.file_id();
        FunctionDefNode {
            name: name.1,
            parameters,
            body,
            return_type,
            span: Some(Span::new(file_id, l..r))
        }
    },
}

Parameters: Vec<VarInitNode> = {
    "(" <parm:Parameter?> ")" => {
        parm.unwrap_or(vec![])
    }
};

// TODO: ellipsis
Parameter: Vec<VarInitNode> = {
    <parms:ParameterList> <_ellipsis:("," "...")?> => {
        parms
    }
};

ParameterList: Vec<VarInitNode> = {
    <list:(<ParameterList> ",")?> <name:ArgName> => {
        let mut v = list.unwrap_or(vec![]);
        v.push(name);
        v
    }
};

ArgName: VarInitNode = {
    <var_type:Type> <mut init:VarInit> => {
        let new_type = LPCType::from(var_type.0);

        init.type_ = new_type.as_array(init.array);

        init
    }
};

Type: (String, Span) = {
    "int" => (String::from("int"), <>),
    "float" => (String::from("float"), <>),
    "string" => (String::from("string"), <>),
    "mixed" => (String::from("mixed"), <>),
    "void" => (String::from("void"), <>),
};

pub Statement: ASTNode = {
    <Expression> => ASTNode::from(<>),
    <Return> => ASTNode::from(<>),
    <Decl> => ASTNode::from(<>)
};

VarInit: VarInitNode = {
    <array:"*"?> <name:"ID"> <value:("=" <AssignmentExpression>)?> => {
        let name_span = name.0;
        let file_id = name_span.file_id;
        let l = if let Some(span) = &array {
            span.l
        } else {
            name_span.l
        };
        let r = if let Some(node) = &value {
            if let Some(span) = &node.span() {
                span.r
            } else {
                name_span.r
            }
        } else {
            name_span.r
        };


        VarInitNode {
            type_: LPCType::Int(false), // placeholder. Corrected in Decl.
            name: name.1,
            value,
            array: array.is_some(),
            global: false,
            span: Some(Span::new(file_id, l..r))
        }
    }
}

pub Decl: DeclNode = {
    <var_type:Type> <init:VarInit> <optional:("," <VarInit>)*> => {
        let new_type = LPCType::from(var_type.0).as_array(init.array);
        let mut initializations = vec![init];

        initializations.append(optional.to_vec().as_mut());

        // Update each VarInitNode with the correct type.
        for init in &mut initializations {
            init.update_type(new_type)
        }

        DeclNode {
            type_: new_type,
            initializations
        }
    }
}

pub PrimaryExpression: ExpressionNode = {
    <Int>,
    <Float>,
    <String>,
    <Var>,
    "(" <Expression> ")",
    "(" "{" <l:ExpressionList?> "}" ")" => {
        let vec = if let Some(list) = l {
            list
        } else {
            vec![]
        };

        ExpressionNode::Array(ArrayNode::new(vec))
    }
};

pub PostfixExpression: ExpressionNode = {
    <PrimaryExpression>,
    <l:PostfixExpression> "[" <r:Expression> <right:"]"> => {
        let file_id = first_span(&[&l, &r]).file_id;
        let left = if let Some(span) = l.span() {
            span.l
        } else {
            0
        };

        collapse_expression(BinaryOperation::Index, l, r, Span { file_id, l: left, r: right.r })
    },
    <l:PostfixExpression> "["  <e1:Expression> ".." <e2:Expression> <right:"]"> => {
        let file_id = first_span(&[&l, &e1, &e2]).file_id;
        let left = if let Some(span) = l.span() {
            span.l
        } else {
            0
        };

        let r = ExpressionNode::Range(RangeNode {
            l: Box::new(Some(e1)),
            r: Box::new(Some(e2)),
            span: Some(Span { file_id, l: left, r: right.r })
        });

        collapse_expression(BinaryOperation::Index, l, r, Span { file_id, l: left, r: right.r })
    },
    <l:PostfixExpression> "[" ".." <e:Expression> <right:"]"> => {
        let file_id = first_span(&[&l, &e]).file_id;
        let left = if let Some(span) = l.span() {
            span.l
        } else {
            0
        };

        let r = ExpressionNode::Range(RangeNode {
            l: Box::new(None),
            r: Box::new(Some(e)),
            span: Some(Span { file_id, l: left, r: right.r })
        });

        collapse_expression(BinaryOperation::Index, l, r, Span { file_id, l: left, r: right.r })
    },
    <l:PostfixExpression> "[" <e:Expression> ".." <right:"]"> => {
        let file_id = first_span(&[&l, &e]).file_id;
        let left = if let Some(span) = l.span() {
            span.l
        } else {
            0
        };

        let r = ExpressionNode::Range(RangeNode {
            l: Box::new(Some(e)),
            r: Box::new(None),
            span: Some(Span { file_id, l: left, r: right.r })
        });

        collapse_expression(BinaryOperation::Index, l, r, Span { file_id, l: left, r: right.r })
    },
    Call => ExpressionNode::Call(<>)
};

pub UnaryExpression: ExpressionNode = {
    <PostfixExpression>,
};

pub CastExpression: ExpressionNode = {
    <UnaryExpression>,
}

pub MultiplicitiveExpression: ExpressionNode = {
    <CastExpression>,
    <l:MultiplicitiveExpression> <op:MultiplicitiveBinaryOp> <r:CastExpression> => {
         let file_id = first_span(&[&l, &r]).file_id;
         let left = if let Some(span) = l.span() {
             span.l
         } else {
             0
         };
         let right = if let Some(span) = r.span() {
             span.r
         } else {
             0
         };

         collapse_expression(op, l, r, Span { file_id, l: left, r: right })
    },
};

pub AdditiveExpression: ExpressionNode = {
    <MultiplicitiveExpression>,
    <l:AdditiveExpression> <op:AdditiveBinaryOp> <r:MultiplicitiveExpression> => {
        let file_id = first_span(&[&l, &r]).file_id;
         let left = if let Some(span) = l.span() {
             span.l
         } else {
             0
         };
         let right = if let Some(span) = r.span() {
             span.r
         } else {
             0
         };

        collapse_expression(op, l, r, Span { file_id, l: left, r: right })
    }
};

pub ShiftExpression: ExpressionNode = {
    <AdditiveExpression>,
};

pub RelationalExpression: ExpressionNode = {
    <ShiftExpression>
};

pub EqualityExpression: ExpressionNode = {
    <RelationalExpression>
};

pub AndExpression: ExpressionNode = {
    <EqualityExpression>
};

pub ExclusiveOrExpression: ExpressionNode = {
    <AndExpression>
};

pub OrExpression: ExpressionNode = {
    <ExclusiveOrExpression>
};

pub LogicalAndExpression: ExpressionNode = {
    <OrExpression>
};

pub LogicalOrExpression: ExpressionNode = {
    <LogicalAndExpression>
};

pub ConditionalExpression: ExpressionNode = {
    <LogicalOrExpression>
};

AssignmentExpression: ExpressionNode = {
    <ConditionalExpression>,
    <lhs:UnaryExpression> <op:AssignmentOp> <rhs:AssignmentExpression> => {
        let file_id = first_span(&[&lhs, &rhs]).file_id;
         let l = if let Some(span) = lhs.span() {
             span.l
         } else {
             0
         };
         let r = if let Some(span) = rhs.span() {
             span.r
         } else {
             0
         };

        ExpressionNode::Assignment(AssignmentNode {
            lhs: Box::new(lhs),
            rhs: Box::new(rhs),
            op,
            span: Some(Span { file_id, l, r }),
        })
    }
};

pub Expression: ExpressionNode = {
    <AssignmentExpression>,
    <e:Expression> <c:","> <ass:AssignmentExpression> => {
        let file_id = if let Some(s) = e.span() {
            s.file_id
        } else if let Some(s) = ass.span() {
            s.file_id
        } else {
            c.file_id
        };

        let l = if let Some(span) = e.span() {
            span.l
        } else {
            c.l
        };
        let r = if let Some(span) = ass.span() {
            span.r
        } else {
            c.r
        };

        let mut list = if let ExpressionNode::CommaExpression(ce) = e {
            ce.value
        } else {
            vec![e]
        };

        list.extend_from_slice(&[ass]);

        ExpressionNode::CommaExpression(CommaExpressionNode {
            value: list,
            span: Some(Span { file_id, l, r })
        })
    }
};

pub Return: ReturnNode = {
    <ret:"return"> <e:Expression?> => {
        let r = if let Some(expr) = &e {
            if let Some(span) = expr.span() {
                span.r
            } else {
                ret.r
            }
        } else {
            ret.r
        };

        ReturnNode { value: e, span: Some(Span { file_id: ret.file_id, l: ret.l, r }) }
    }
}

ExpressionList: Vec<ExpressionNode> = {
    <AssignmentExpression> => vec![<>],
    <list:ExpressionList> "," <arg:AssignmentExpression> => {
        let mut v = list;
        v.push(arg);
        v
    }
};

ArgumentExpressionList: Vec<ExpressionNode> = {
    <AssignmentExpression> => vec![<>],
    <list:ArgumentExpressionList> "," <arg:AssignmentExpression> => {
        let mut v = list;
        v.push(arg);
        v
    }
};

pub Call: CallNode = {
    <name:"ID"> "(" <list:ArgumentExpressionList?> <right:")"> => {
        let arguments = match list {
            Some(args) => args,
            None => vec![]
        };

        let file_id = name.file_id();
        let l = name.0.l;
        let r = right.r;

        CallNode {
            arguments,
            name: name.1,
            span: Some(Span { file_id, l, r })
        }
    }
};

AssignmentOp: AssignmentOperation = {
    "=" => AssignmentOperation::Simple
};

AdditiveBinaryOp: BinaryOperation = {
    "+" => BinaryOperation::Add,
    "-" => BinaryOperation::Sub
};

MultiplicitiveBinaryOp: BinaryOperation = {
    "*" => BinaryOperation::Mul,
    "/" => BinaryOperation::Div
};

Var: ExpressionNode = <name:"ID"> => {
    ExpressionNode::Var(
        VarNode {
            name: name.1,
            span: Some(name.0),
            global: false
        }
    )
};

Int: ExpressionNode = {
    <i:"IntLiteral"> => {
        ExpressionNode::Int(
            IntNode {
                value: i.1,
                span: Some(i.0),
            }
        )
    },
};

Float: ExpressionNode = <f:"FloatLiteral"> => {
    ExpressionNode::Float(
        FloatNode {
            value: f.1,
            span: Some(f.0)
        }
    )
};

String: ExpressionNode = {
    <s:"StringLiteral"> => {
        ExpressionNode::String(
            StringNode {
                value: s.1,
                span: Some(s.0)
            }
        )
    },
    <s1:"StringLiteral"> <s2:String> => {
        let span = s1.0;
        let file_id = span.file_id;
        let l = span.l;

        match s2 {
            ExpressionNode::String(node) => {
                let r = if let Some(span) = &node.span {
                    span.r
                } else {
                    l
                };
                ExpressionNode::String(StringNode {
                    value: s1.1 + &node.value,
                    span: Some(Span { file_id, l, r })
                })
            }
            _ => unimplemented!()
        }
    },
};
