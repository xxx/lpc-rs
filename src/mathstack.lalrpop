use std::str::FromStr;

use crate::ast::program_node::ProgramNode;
use crate::ast::binary_op_node::{BinaryOperation, BinaryOpNode};
use crate::ast::expression_node::ExpressionNode;
use crate::ast::int_node::IntNode;
use crate::ast::call_node::CallNode;

grammar;

SemiSeq<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Program: ProgramNode = <expressions:SemiSeq<Statement>> => ProgramNode {
    expressions
};

pub Statement = <Expression>;

pub Expression: ExpressionNode = {
    <l:Term> <op:BinaryOp> <r:Expression> => ExpressionNode::BinaryOp(BinaryOpNode { l: Box::new(l), r: Box::new(r), op }),
    <Term>,
    <c:Call> => ExpressionNode::Call(c)
};

pub Call: CallNode = {
    <id:ID> "(" <e:Expression> ")" => CallNode {
        arguments: vec![e],
        id
    }
};

BinaryOp: BinaryOperation = {
    "+" => BinaryOperation::Add,
    "-" => BinaryOperation::Sub,
    "*" => BinaryOperation::Mul,
    "/" => BinaryOperation::Div
};

Term: ExpressionNode = {
    <Int>,
    "(" <Expression> ")",
};

Int: ExpressionNode = <s:r"-?[0-9]+"> => ExpressionNode::Int(IntNode {
    value: i64::from_str(s).unwrap()
});

ID: String = <i:r"[\p{Alphabetic}_]\w+"> => String::from(i);